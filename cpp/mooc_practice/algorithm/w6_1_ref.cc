/************************************************************
**文件名：百炼-1321
**Copyright (c) 2015-2025 OrdinaryCrazy
**创建人：OrdinaryCrazy
**日期：20170809
**描述：百炼1321参考答案
**版本：1.0
*************************************************************/
#include <stdio.h>
#include <string.h>
char board[8][9];
int num, n, occupied[8]; //记录列的占用情况
/*************************************************************
首先分析这个问题的状态有两个：
还有多少棋子要放上去，棋盘目前的情况，
这里需要注意的是有这样一种情况会造成重解，
你和你后面的那位刚好仅仅互换了位置
所以出现隐藏状态：现在的第一个棋子要从哪一位开始放
注意与八皇后中类似的行列检验方法，提高速度的关键
**************************************************************/
/*************************************************************
**函数名：solve
**输入：k-还有多少个棋子需要填入，a-可以填入的最优先位置的行
**功能：搜索将k个棋子填入(a,0)以后位置的所有可行解
**作者：OrdinaryCrazy
**日期：20170809
**版本：1.0
**************************************************************/
void solve(int k, int a) {
  if (k == 0) //找到了一种解
  {
    num++;
    return;
  }
  int i, j;
  for (i = a; i < n; i++)
    for (j = 0; j < n; j++)
      if (board[i][j] == '#' && !occupied[j]) //找到了一个合适的位置
      {
        occupied[j] = 1;
        if (i != n - 1)
          solve(k - 1, i + 1);
        else if (k == 1)
          num++;
        occupied[j] = 0;
      }
}
int main() {

  int k, i;
  scanf("%d%d", &n, &k);
  while (n + 1) {
    for (i = 0; i < n; i++)
      scanf("%s", board[i]);
    num = 0;
    memset(occupied, 0, sizeof(occupied));
    solve(k, 0);
    printf("%d\n", num);
    scanf("%d%d", &n, &k);
  }
  return 0;
}
