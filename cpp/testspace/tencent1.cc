
 struct ListNode {
 int val;
 struct ListNode *next;
 };
 

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param S ListNode类 val表示权值，next指向下一个元素
     * @return ListNode类
     */
    ListNode* solve(ListNode* S) {
        // write code here
        void mm(string args[]) {
          int less = 0;
          ListNode min = new ListNode(0);
          int len = count(head);
          int min = head.val;
          copy(min, head);
          ListNode temp = head;
          for(int i(0); i < len; ++i) {
            i
          }
          return min.next;

        }
    }
    int count (ListNode *head) {
      int *temp1 = head;
      int len = 0;
      while (temp1 != nullptr) {
        ++len;
        temp1 = temp1.next;
      }
      return len;
    }
    bool cmp(const ListNode *head1, const ListNode *head2) {
      list
      while (head1 != nullptr) {
        if (temp1.val > temp2.val) {
          return false;
        }
        temp1 = temp1.next;
        
      }
    }
};